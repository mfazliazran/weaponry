<?xml version="1.0"?>
<!DOCTYPE bindings [
<!ENTITY % common-dtd SYSTEM "chrome://weaponry/locale/common.dtd">%common-dtd;
<!ENTITY % brand-dtd SYSTEM "chrome://branding/locale/brand.dtd">%brand-dtd;
]>
<bindings
	xmlns="http://www.mozilla.org/xbl"
	xmlns:xbl="http://www.mozilla.org/xbl"
	xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

	<!-- copied from chrome://global/content/bindings/tabbox.xml with some modifications -->
	<binding id="_tab-extension" display="xul:tab" extends="chrome://global/content/bindings/tabbox.xml#tab">
		<resources>
			<stylesheet src="chrome://weaponry/content/common.css"/>
		</resources>
		<content>
			<xul:hbox class="tab-middle box-inherit" xbl:inherits="align,dir,pack,orient,selected" flex="1">
				<xul:image class="tab-icon" xbl:inherits="validate,src=image"/>
				<xul:label class="tab-text" xbl:inherits="value=label,accesskey,crop,disabled" flex="1"/>
			</xul:hbox>
			<xul:toolbarbutton id="_tab-extension-toolbarbutton" xbl:inherits="oncommand=onbuttonclick"/>
		</content>
		<implementation>
			<property name="hbox" onget="return document.getAnonymousNodes(this)[0]"/>
			<property name="tabIcon" onget="return this.hbox.childNodes[0]"/>
			<property name="tabText" onget="return this.hbox.childNodes[1]"/>
			<property name="toolBarButton" onget="return document.getAnonymousNodes(this)[1]"/>
			<property name="onbuttonclick" onget="return this.toolBarButton.onclick" onset="this.toolBarButton.onclick = val"/>
			<constructor><![CDATA[
				// make sure that mousedown events on the button do not result in the tab getting selected
				this.toolBarButton.addEventListener('mousedown', function (event) {
					event.preventDefault();
					event.stopPropagation();
				}, true);
			]]></constructor>
		</implementation>
	</binding>

	<!-- ==================================================================================================== -->

	<binding id="tabmanager">
		<resources>
			<stylesheet src="chrome://weaponry/content/common.css"/>
		</resources>
		<content>
			<xul:tabbox id="tabmanager-tabbox" xbl:inherits="flex">
				<xul:arrowscrollbox id="tabmanager-arrowscrollbox" orient="horizontal">
					<xul:tabs id="tabmanager-tabs"/>
				</xul:arrowscrollbox>
				<xul:tabpanels id="tabmanager-tabpanels" flex="1"/>
			</xul:tabbox>
		</content>
		<implementation>
			<property name="tabBox" onget="return document.getAnonymousNodes(this)[0]"/>
			<property name="arrowScrollBox" onget="return this.tabBox.childNodes[0]"/>
			<property name="tabPanels" onget="return this.tabBox.childNodes[1]"/>
			<property name="tabs" onget="return this.arrowScrollBox.childNodes[0]"/>
			<property name="selectedIndex" onget="return this.tabs.selectedIndex" onset="this.tabs.selectedIndex = val"/>
			<property name="selectedTab" onget="return this.getTab()" onset="this.selectedIndex = val.tabIndex"/>
			<property name="selectedTabPanel" onget="return this.selectedTab.tabPanel"/>
			<method name="getTab">
				<parameter name="tabIndex"/>
				<body><![CDATA[
					// find numIndex from tabIndex
					switch(typeof(tabIndex)) {
						case 'undefined': // if no tabIndex given than we want the selected tab
							var numIndex = this.tabs.selectedIndex;
							break;
						case 'number': // if tabIndex is a number than try to find the tab, otherwise return undefined
							var numIndex = (tabIndex < this.tabs.childNodes.length) ? tabIndex : undefined;
							break;
						case 'object': // if object given than try to find the object within the current tabs
							var numIndex = [].slice.call(tabIndex.parentNode.childNodes, 0).indexOf(tabIndex);
							break;
						default: // if all failed than just make the rest of the code fail as well
							var numIndex = undefined;
							break;
					}

					// if numIndex is undefined or less than 0 than...
					if (typeof(numIndex) == 'undefined' || numIndex < 0) {
						// ...return null
						return null;
					} else { // otherwise...
						// ...return the tab at numIndex
						return this.tabs.childNodes[numIndex];
					}
				]]></body>
			</method>
			<method name="openTab">
				<parameter name="tabContent"/>
				<parameter name="tabLabel"/>
				<parameter name="focus"/>
				<body><![CDATA[
					// asign some constants
					const NSXUL = 'http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul';

					// create tab
					var tab = document.createElementNS(NSXUL, 'tab');
					tab.setAttribute('label', tabLabel);

					// create tab panel
					var tabPanel = document.createElementNS(NSXUL, 'tabpanel');
					tabPanel.appendChild(tabContent);

					// wire both tab and tabPanel
					this.tabs.appendChild(tab);
					this.tabPanels.appendChild(tabPanel);

					// add special properties tabPanel, tabContent
					tab.tabPanel = tabPanel;
					tab.tabContent = tabContent;

					// make manager this
					var manager = this;

					// wire tab onbuttonclick to make it a close button
					tab.onbuttonclick = function (event) {
						manager.closeTab(tab); // close tab when button clicked
					}

					// focus tab
					if (focus) {
						this.tabs.selectedIndex = this.tabs.childNodes.length - 1;
					}

					// fire event
					var event = document.createEvent('Events');
					event.initEvent('TabOpen', true, false);
					this.dispatchEvent(event);

					// return the tab
					return tab;
				]]></body>
			</method>
			<method name="closeTab">
				<parameter name="tabIndex"/>
				<body><![CDATA[
					// get the tab that we want to close
					var tab = this.getTab(tabIndex);

					// if a tab found than...
					if (tab != null) {
						// get the tab index
						var tabIndex = [].slice.call(tab.parentNode.childNodes, 0).indexOf(tab);

						// get selected index
						var selectedIndex = this.selectedIndex;

						// remove tabpanel and tab
						this.tabPanels.removeChild(tab.tabPanel);
						this.tabs.removeChild(tab);

						// select next
						if (tabIndex == selectedIndex) { // if the tab that we are about to close is the selected one...
							// the new selected index should be the tab index minus 1 because we need to go one possition down
							var newSelectedIndex = tabIndex - 1;

							if (newSelectedIndex < 0 && this.tabs.childNodes.length > 0) { // if the new selected index is less than 0 but we stil have at least one tab...
								// ...select the very first tab
								this.selectedIndex = 0;
							} else { // otherwise...
								// ...select the new index
								this.selectedIndex = newSelectedIndex;
							}
						} else { // else if the tab that we are about the close is not the selected one...
							// ...keep the selected tab selected
							this.selectedIndex = selectedIndex - 1;
						}

						// fire event to notify that a tab has been closed
						var event = document.createEvent('Events');
						event.initEvent('TabClose', true, false);
						this.dispatchEvent(event);
					}
				]]></body>
			</method>
			<method name="getTabContent">
				<parameter name="tabIndex"/>
				<body><![CDATA[
					// find tab
					var tab = this.getTab(tabIndex);

					// return its content
					return tab.tabContent;
				]]></body>
			</method>
		</implementation>
		<handlers>
			<handler event="keypress" key="w" modifiers="control" action="this.closeTab()"/>
		</handlers>
	</binding>

	<!-- ==================================================================================================== -->

	<binding id="browsernavigationbox">
		<resources>
			<stylesheet src="chrome://weaponry/content/common.css"/>
		</resources>
		<content>
			<xul:toolbox id="browsernavigationbox-toolbox" orient="horizontal" flex="1">
				<xul:toolbar id="browsernavigationbox-toolbar" flex="1">
					<xul:toolbarbutton id="browsernavigationbox-back-button" label="&browsernavigationbox-back-button-label;" disabled="true"/>
					<xul:toolbarbutton id="browsernavigationbox-forward-button" label="&browsernavigationbox-forward-button-label;" disabled="true"/>
					<xul:toolbarbutton id="browsernavigationbox-reload-button" label="&browsernavigationbox-reload-button-label;"/>
					<xul:toolbarbutton id="browsernavigationbox-stop-button" label="&browsernavigationbox-stop-button-label;" disabled="true"/>
					<xul:textbox id="browsernavigationbox-location-bar" value="" flex="1"/>
					<xul:toolbarbutton id="browsernavigationbox-go-button" label="&browsernavigationbox-go-button-label;"/>
				</xul:toolbar>
			</xul:toolbox>
		</content>
		<implementation>
			<property name="toolBox" onget="return document.getAnonymousNodes(this)[0]"/>
			<property name="toolBar" onget="return this.toolBox.childNodes[0]"/>
			<property name="backButton" onget="return this.toolBar.childNodes[0]"/>
			<property name="forwardButton" onget="return this.toolBar.childNodes[1]"/>
			<property name="reloadButton" onget="return this.toolBar.childNodes[2]"/>
			<property name="stopButton" onget="return this.toolBar.childNodes[3]"/>
			<property name="locationBar" onget="return this.toolBar.childNodes[4]"/>
			<property name="goButton" onget="return this.toolBar.childNodes[5]"/>
			<method name="wire">
				<parameter name="browser"/>
				<body><![CDATA[
					// unwire first
					this.unwire();

					// make this navbar
					var navbar = this;

					// web progress listener
					function WebProgressListener() {}
					WebProgressListener.prototype = {
						QueryInterface: function(iid) {
							if (iid.equals(Components.interfaces.nsIWebProgressListener) ||
							    iid.equals(Components.interfaces.nsISupportsWeakReference) ||
							    iid.equals(Components.interfaces.nsISupports)) {
								return this;
							}
					    
							throw Components.results.NS_ERROR_NO_INTERFACE;
						},
						onStateChange: function(webProgress, request, stateFlags, status) {
							const WPL = Components.interfaces.nsIWebProgressListener;

							if (stateFlags & WPL.STATE_IS_NETWORK) {
								if (stateFlags & WPL.STATE_START) {
									navbar.stopButton.setAttribute('disabled', false);
								} else if (stateFlags & WPL.STATE_STOP) {
									navbar.stopButton.setAttribute('disabled', true);
									this.onStatusChange(webProgress, request, 0, 'Done');
								}
							}
						},
						onLocationChange: function(webProgress, request, location) {
							navbar.locationBar.value = location.spec;

							navbar.backButton.setAttribute("disabled", !browser.canGoBack);
							navbar.forwardButton.setAttribute("disabled", !browser.canGoForward);
						},
						onProgressChange: function(webProgress, request, curSelf, maxSelf, curTotal, maxTotal) {},
						onStatusChange: function(webProgress, request, status, message) {},
						onSecurityChange: function(webProgress, request, state) {},
					}

					// persist the browser
					this.browser = browser;

					// persist the listener
					this.progressListener = new WebProgressListener();

					// wire the progress listener
					browser.addProgressListener(this.progressListener, Components.interfaces.nsIWebProgress.NOTIFY_ALL);

					// wire the navigation buttons and the locationBar
					this.backButton.onclick = function () {
						browser.stop();
						browser.goBack();
					}
					this.forwardButton.onclick = function () {
						browser.stop();
						browser.goForward();
					}
					this.reloadButton.onclick = function () {
						browser.stop();
						browser.reload();
					}
					this.stopButton.onclick = function () {
						browser.stop();
					}
					this.goButton.onclick = function () {
						browser.loadURI(navbar.locationBar.value, null, null);
					}
					this.locationBar.onchange = function () {
						browser.loadURI(navbar.locationBar.value, null, null);
					}
				]]></body>
			</method>
			<method name="unwire">
				<body><![CDATA[
					// if we have been wired...
					if (typeof(this.progressListener) != 'undefined') {
						// ...unwire by removing the progressListener
						this.browser.removeProgressListener(this.progressListener);

						// ...and by also removing the button and textbox events
						this.backButton.onclick = undefined;
						this.forwardButton.onclick = undefined;
						this.reloadButton.onclick = undefined;
						this.stopButton.onclick = undefined;
						this.goButton.onclick = undefined;
						this.locationBar.onchange = undefined;

						// ...and remove the progressListener
						this.progressListener = undefined;

						// ...and return button state
						this.backButton.setAttribute('disabled', true);
						this.forwardButton.setAttribute('disabled', true);
						this.stopButton.setAttribute('disabled', true);
					}
				]]></body>
			</method>
			<destructor><![CDATA[
				// try to unwire
				this.unwire()
			]]></destructor>
		</implementation>
	</binding>

	<!-- ==================================================================================================== -->

	<binding id="integratedbrowser">
		<resources>
			<stylesheet src="chrome://weaponry/content/common.css"/>
		</resources>
		<content>
			<xul:vbox xbl:inherits="flex">
				<xul:browsernavigationbox id="integratedbrowser-browsernavigationbox"/>
				<xul:notificationbox id="integratedbrowser-notificationbox" flex="1">
					<xul:browser id="integratedbrowser-browser" src="about:blank" type="content-primary" flex="1" xbl:inherits="src,type"/>
				</xul:notificationbox>
			</xul:vbox>
		</content>
		<implementation>
			<property name="browserNavigationBox" onget="return document.getAnonymousNodes(this)[0].childNodes[0]"/>
			<property name="notificationBox" onget="return document.getAnonymousNodes(this)[0].childNodes[1]"/>
			<property name="browser" onget="return document.getAnonymousNodes(this)[0].childNodes[1].childNodes[0]"/>
			<method name="loadURI">
				<parameter name="URI"/>
				<parameter name="args"/>
				<body><![CDATA[
					// make a global shortcut to the browser
					var browser = this.browser;

					// deal with args
					if (typeof(args) != 'undefined') { // if args provides...
						// ...define a progress listener
						var progressListener = null;

						// ...register a new progress listener class
						function ProgressListener() {}
						ProgressListener.prototype = {
							QueryInterface: function(iid) {
								if (iid.equals(Components.interfaces.nsIProgressListener) ||
								    iid.equals(Components.interfaces.nsISupportsWeakReference) ||
								    iid.equals(Components.interfaces.nsISupports)) {
									return this;
								}
						    
								throw Components.results.NS_ERROR_NO_INTERFACE;
							},
							onLocationChange: function(webProgress, request, location) {
								// set the window arguments
								browser.contentWindow.wrappedJSObject.arguments = [args];

								// remove the progress listener once we are done with setting up the args
								browser.removeProgressListener(progressListener);
							},
							onStateChange: function(webProgress, request, stateFlags, status) {},
							onProgressChange: function(webProgress, request, curSelf, maxSelf, curTotal, maxTotal) {},
							onStatusChange: function(webProgress, request, status, message) {},
							onSecurityChange: function(webProgress, request, state) {},
						}

						// ...create an instance of a progress listener
						progressListener = new ProgressListener();

						// ...add progress listener to the browser
						browser.addProgressListener(progressListener, Components.interfaces.nsIWebProgress.NOTIFY_ALL);
					}

					// load the specified URI
					browser.loadURI(URI);
				]]></body>
			</method>
			<constructor><![CDATA[
				// wire browser to the navigation bar
				this.browserNavigationBox.wire(this.browser);
			]]></constructor>
			<destructor><![CDATA[
				// unwire the browser from the navigation bar
				this.browserNavigationBox.unwire();
			]]></destructor>
		</implementation>
		<handlers>
			<handler event="keypress" key="d" modifiers="alt" action="this.browserNavigationBox.locationBar.focus()"/>
		</handlers>
	</binding>

	<!-- ==================================================================================================== -->

	<binding id="integratedtabbrowser">
		<resources>
			<stylesheet src="chrome://weaponry/content/common.css"/>
		</resources>
		<content>
			<xul:tabmanager id="integratedtabbrowser-tabmanager" xbl:inherits="flex"/>
		</content>
		<implementation>
			<property name="tabManager" onget="return document.getAnonymousNodes(this)[0]"/>
			<method name="openTab">
				<parameter name="URI"/>
				<parameter name="focus"/>
				<parameter name="args"/>
				<body><![CDATA[
					// if no URI given than use about:blank
					if (typeof(URI) == 'undefined') {
						URI = 'about:blank';
					}

					// asign some constants
					const NSXUL = 'http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul';

					// create integratedbrowser
					var integratedbrowser = document.createElementNS(NSXUL, 'integratedbrowser');
					integratedbrowser.setAttribute('flex', 1);

					// open tab
					var tab = this.tabManager.openTab(integratedbrowser, undefined, focus);

					// load URI
					integratedbrowser.loadURI(URI, args);

					// add DOMTitleChanged event listener to integratedbrowser
					integratedbrowser.browser.addEventListener('DOMTitleChanged', function () {
						tab.setAttribute('label', this.contentTitle ? this.contentTitle : undefined);
					}, true);

					// add click event listener to browser
					integratedbrowser.browser.addEventListener('click', function () {
						// TODO: add code to handle when user clicks on <A> with target attributes
					}, true);

					// return the newly created tab
					return tab;
				]]></body>
			</method>
			<constructor><![CDATA[
				// capture select events from tabmanager
				this.tabManager.addEventListener('select', function () {
					// make all browsers content-targetable
					for (var i = 0; i < this.tabs.childNodes.length; i++) {
						this.tabs.childNodes[i].tabContent.browser.setAttribute('type', 'content-targetable');
					}

					// make the selected browser content-primary
					this.tabs.childNodes[this.selectedIndex].tabContent.browser.setAttribute('type', 'content-primary');
				}, true);
			]]></constructor>
		</implementation>
	</binding>

</bindings>
