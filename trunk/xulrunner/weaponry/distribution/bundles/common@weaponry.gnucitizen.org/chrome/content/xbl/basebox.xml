<?xml version="1.0"?>
<!--
 *  basebox.xml
 *  Copyright (C) 2007-2011  GNUCITIZEN
 *  
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *  
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-->
<!DOCTYPE bindings SYSTEM "chrome://common.weaponry.gnucitizen.org/locale/xbl/basebox.dtd">
<bindings
	xmlns="http://www.mozilla.org/xbl"
	xmlns:xbl="http://www.mozilla.org/xbl"
	xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
	
	<binding id="basebox">
		<resources>
			<stylesheet src="chrome://common.weaponry.gnucitizen.org/content/css/bindings.css"/>
		</resources>
		
		<implementation>
			<method name="_removeChildren">
				<parameter name="$element"/>
				
				<body><![CDATA[
					while ($element.hasChildNodes()) {
					    $element.removeChild($element.lastChild);
					}
				]]></body>
			</method>
			
			<method name="_copyChildren">
				<parameter name="$sourceElement"/>
				<parameter name="$destinationElement"/>
				
				<body><![CDATA[
					let nodes = $sourceElement.childNodes;
					let nodesLength = nodes.length;
					
					for (let i = 0; i < nodesLength; i += 1) {
						$destinationElement.appendChild(nodes[i].cloneNode(true));
					}
				]]></body>
			</method>
			
			<method name="_getChildIndex">
				<parameter name="$parent"/>
				<parameter name="$child"/>
				
				<body><![CDATA[
					let childNodes = $parent.childNodes;
					let childNodesLength = childNodes.length;
					
					for (let i = 0; i < childNodesLength; i += 1) {
						let $node = childNodes[i];
						
						if ($node == $child) {
							return i;
						}
					}
					
					return -1;
				]]></body>
			</method>
			
			<method name="_fireEvent">
				<parameter name="eventName"/>
				<parameter name="data"/>
				
				<body><![CDATA[
					let event = document.createEvent('Event');
					
					event.initEvent(eventName, true, true);
					
					if (data) {
						event.data = data;
					}
					
					if (this.hasAttribute('on' + eventName.toLowerCase())) {
						with({event: event}) {
							let result = eval('(function (event) {' + this.getAttribute('on' + eventName.toLowerCase()) + '})(event)');
							
							if (result == false) {
								event.preventDefault();
							}
						}
					}
					
					if (this['on' + eventName.toLowerCase()]) {
						let result = this['on' + eventName.toLowerCase()](event);
						
						if (result == false) {
							event.preventDefault();
						}
					}
					
					return this.dispatchEvent(event);
				]]></body>
			</method>
			
			<method name="_bindEvent">
				<parameter name="$element"/>
				<parameter name="event"/>
				<parameter name="handler"/>
				
				<body><![CDATA[
					if (!('_boundEvents' in this) || !this._boundEvents) {
						this._boundEvents = [];
					}
					
					this._boundEvents.push([$element, event, handler]);
					
					$element.addEventListener(event, handler, false);
				]]></body>
			</method>
			
			<method name="_lockEvent">
				<parameter name="$element"/>
				<parameter name="event"/>
				<parameter name="handler"/>
				
				<body><![CDATA[
					this._bindEvent($element, event, function (event) {
						if (event.originalTarget == this) {
							handler.apply(this, arguments);
						}
					});
				]]></body>
			</method>
			
			<method name="_bindAttributes">
				<parameter name="$sourceElement"/>
				<parameter name="$destinationElement"/>
				<parameter name="attributes"/>
				<parameter name="assigner"/>
				
				<body><![CDATA[
					if (!assigner) {
						assigner = function ($from, fromValue, $to, toValue) {
							$to.setAttribute(toValue, $from.getAttribute(fromValue));
						};
					}
					
					let attributeLookupTable = {};
					let attributesLength = attributes.length;
					
					for (let i = 0; i < attributesLength; i += 1) {
						let attribute = attributes[i];
						let attributeName = attribute;
						let attributeLookup = attribute;
						
						if (attribute.indexOf('=') >= 0) {
							attributeName = attribute.split(/\s*=/g)[0];
							attributeLookup = attribute.split(/=\s*/g)[1];
						}
						
						attributeLookupTable[attributeName] = attributeLookup;
						
						if ($sourceElement.hasAttribute(attributeLookup)) {
							assigner($sourceElement, attributeLookup, $destinationElement, attributeName);
						}
					}
					
					this._lockEvent($sourceElement, 'DOMAttrModified', function (event) {
						if (event.attrName in attributeLookupTable) {
							assigner(event.target, event.attrName, $destinationElement, attributeLookupTable[event.attrName]);
						}
					});
					
					this._bindEvent($destinationElement, 'DOMAttrModified', function (event) {
						if (event.attrName in attributeLookupTable) {
							assigner(event.target, event.attrName, $sourceElement, attributeLookupTable[event.attrName]);
						}
					});
				]]></body>
			</method>
			
			<method name="_generateId">
				<body><![CDATA[
					return 'id-' + (new Date()).getTime().toString() + Math.random().toString().substring(2);
				]]></body>
			</method>
			
			<method name="_wireNode">
				<parameter name="$node"/>
				
				<body><![CDATA[
					// pass
				]]></body>
			</method>
			
			<method name="_unwireNode">
				<parameter name="$node"/>
				
				<body><![CDATA[
					// pass
				]]></body>
			</method>
			
			<constructor>
				<action><![CDATA[
					if (!this.id) {
						this.id = this._generateId();
					}
					
					this._bindEvent(this, 'DOMNodeRemoved', function (event) {
						if (event.originalTarget == this && this.parentNode && '_unwireNode' in this.parentNode && this.parentNode._unwireNode) {
							this.parentNode._unwireNode(this);
						}
					});
					
					if (this.parentNode && '_wireNode' in this.parentNode && this.parentNode._wireNode) {
						this.parentNode._wireNode(this);
					}
				]]></action>
			</constructor>
			
			<destructor>
				<action><![CDATA[
					if ('_boundEvents' in this && this._boundEvents) {
						let boundEventsLength = this._boundEvents.length;
						
						for (let i = 0; i < boundEventsLength; i += 1) {
							let event = this._boundEvents[i];
							
							event[0].removeEventListener(event[1], event[2], false);
						}
						
						this._boundEvents = [];
					}
				]]></action>
			</destructor>
		</implementation>
	</binding>
	
</bindings>
<!--
 *  GNUCITIZEN (Information Security Think Tank)
 ***********************************************
-->